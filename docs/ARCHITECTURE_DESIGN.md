# 架构设计 (Architecture Design)

> 本文档描述 Chronos OS 的系统架构设计与实现细则，旨在为开发者提供清晰的技术蓝图。

## 系统架构图

```
┌─────────────────────────────────────────┐
│          用户应用程序 (U-mode)          │
│  ┌─────────────┐  ┌─────────────┐     │
│  │ 00poweroff  │  │ 01hello     │     │
│  └─────────────┘  └─────────────┘     │
└─────────────────────────────────────────┘
                 │ ecall
                 ↓
┌─────────────────────────────────────────┐
│         操作系统内核 (S-mode)           │
│  ┌─────────────┬─────────────┬─────────┐ │
│  │  系统调用   │   任务管理   │ 中断处理 │ │
│  │  (syscall)  │   (task)    │ (trap)  │ │
│  └─────────────┴─────────────┴─────────┘ │
│  ┌─────────────────────────────────────┐ │
│  │           内存管理 (mm)              │ │
│  │  Frame Alloc | Page Table | Heap     │ │
│  └─────────────────────────────────────┘ │
│  ┌─────────────────────────────────────┐ │
│  │          设备驱动 (drivers)          │ │
│  │           UART | Block Device        │ │
│  └─────────────────────────────────────┘ │
└─────────────────────────────────────────┘
                 │ SBI calls
                 ↓
┌─────────────────────────────────────────┐
│      固件层 - RustSBI (M-mode)          │
│  ┌─────────────────────────────────────┐ │
│  │  硬件初始化 | 内存保护 | 引导内核   │ │
│  └─────────────────────────────────────┘ │
└─────────────────────────────────────────┘
                 │
                 ↓
┌─────────────────────────────────────────┐
│            硬件层 (QEMU)               │
│      RISC-V 64 CPU + 内存 + 设备        │
└─────────────────────────────────────────┘
```

---

## 1. 宏观架构：特权级分层

Chronos OS 基于 RISC-V 架构标准的特权级机制，采用经典的分层设计，以确保系统的稳定性与安全性。

### 1.1 硬件与固件 (M-Mode)
最底层为 Machine Mode (M-Mode)，直接与硬件交互。
*   **组件**: **QEMU / RustSBI**。
*   **职责**:
    *   **硬件屏蔽**: 屏蔽底层硬件差异，提供统一的 SBI 接口调用。
    *   **启动引导**: 负责硬件初始化，并将控制权移交给内核。

### 1.2 操作系统内核 (S-Mode)
中间层为 Supervisor Mode (S-Mode)，即操作系统内核。
*   **组件**: **Chronos Kernel**。
*   **职责**:
    *   **资源管理**: 统一管理 CPU、内存与外设资源。
    *   **隔离保护**: 在用户程序之间建立保护边界。
    *   **中断处理**: 响应硬件中断与异常。

### 1.3 用户空间 (U-Mode)
最上层为 User Mode (U-Mode)，即用户应用程序。
*   **组件**: **User Applications**。
*   **限制**:
    *   运行在受限的虚拟地址空间中。
    *   无法直接访问物理硬件。
    *   用户程序必须通过系统调用（System Call）请求内核服务。

---

## 2. 关键设计决策 (Design Decisions)

在 Chronos OS 的开发过程中，我们基于安全性与性能的考量，做出了以下技术选型：

### 2.1 编程语言：Rust
我们选择 Rust 作为开发语言，主要基于以下原因：
*   **内存安全**: Rust 的所有权（Ownership）与借用（Borrowing）机制在编译期有效防止了空指针、悬垂指针等内存错误。
*   **零成本抽象**: 提供了高级语言的抽象能力，同时保持了与 C/C++ 相当的运行时性能。
*   **现代构建工具**: Cargo 构建系统简化了依赖管理与构建流程。

### 2.2 内存模型：SV39 分页
*   **选择**: RISC-V SV39 分页机制。
*   **理由**: 符合 RISC-V 64 位标准。提供 39 位虚拟地址空间（512 GB），三级页表结构在查询效率与存储开销之间取得了平衡。

### 2.3 动态内存分配：伙伴系统 (Buddy System)
*   **选择**: Buddy System Allocator。
*   **理由**:
    *   有效减少外部碎片。
    *   分配与释放操作的时间复杂度为 O(log N)，性能稳定。
    *   相比链表分配器，更适合操作系统的长期运行需求。

### 2.4 任务调度
*   **协作式调度**: Cooperative Scheduling。任务需要主动调用 `sys_yield` 让出 CPU。
*   **抢占式调度**: Preemptive Scheduling。通过任务优先级进行调度

---

## 3. 启动流程 (Boot Process)

系统加电启动的完整流程如下：

1.  **QEMU (Power On)**:
    物理复位。PC 指针重置，内部固化代码将控制权跳转至 `0x80000000`。

2.  **RustSBI (Bootloader)**:
    *   运行于 `0x80000000` (M-Mode)。
    *   执行必要的硬件初始化（如 UART 串口）。
    *   解析平坦设备树（FDT）以获取内存与外设信息。
    *   特权级切换至 S-Mode，跳转至内核入口地址 `0x80200000`。

3.  **Kernel Main (Initialization)**:
    *   **Entry (`entry.S`)**: 初始化内核栈 (`BootStack`)，为 Rust 运行时做准备。
    *   **mm_init**: 初始化物理页帧分配器，建立页表与虚拟内存映射，开启 MMU。
    *   **trap_init**: 设置 `stvec` 寄存器，初始化中断向量表。
    *   **task_init**: 初始化任务管理器，加载首个用户程序至就绪队列。

---

## 4. 模块职责划分

Chronos OS 采用模块化设计，各子系统职责明确：

| 模块目录 | 职责 | 关键组件 |
| :--- | :--- | :--- |
| `kernel/src/mm` | **内存管理** | 物理页分配器, 页表, 堆, 地址空间 (MemorySet) |
| `kernel/src/task` | **任务管理** | 任务控制块 (TCB), 调度器, 上下文切换 |
| `kernel/src/trap` | **中断异常** | Trap 上下文, 修改 `scause`, 系统调用分发 |
| `kernel/src/syscall` | **系统调用** | 文件 I/O, 进程管理 |
| `kernel/src/drivers` | **设备驱动** | UART 驱动, 块设备驱动 |

---

## 5. 总结

Chronos OS 采用宏内核（Monolithic Kernel）架构，强调实现的简洁性与正确性。系统设计遵循 RISC-V 标准规范，通过模块化解耦降低了系统复杂度，适合作为操作系统原理的学习与研究平台。