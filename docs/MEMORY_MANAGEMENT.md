# Chronos OS 内存管理架构设计

## 1. 概述

Chronos OS 的内存管理子系统负责物理内存的分配与回收、虚拟地址到物理地址的映射以及不同特权级地址空间的管理。系统基于 RISC-V SV39 分页机制实现，采用了 RAII 风格的资源管理策略确保内存安全，并实现了内核与用户空间的强隔离。

本文档详细描述了 v0.2.0 版本的内存管理架构，涵盖物理内存管理、虚拟内存映射、地址空间抽象及动态堆分配等核心模块。

## 2. 物理内存管理

物理内存管理模块位于 `mm/frame_allocator.rs`，其核心职责是管理物理页帧（Physical Frame）的分配与回收。

### 2.1 物理地址空间布局

根据 `config.rs` 定义，物理内存布局如下：
- **物理内存起始地址**: `0x8000_0000`
- **物理内存结束地址**: `0x8800_0000` (总计 128MB)
- **标准页大小**: 4096 字节 (4KB)

### 2.2 物理帧分配器 (Bitmap Allocator)

系统采用基于位图（Bitmap）的分配算法来高效管理物理页帧。

- **数据结构**: 使用 `AtomicUsize` 数组存储位图，确保多核环境下的线程安全。
- **分配策略**: 维护一个全局游标 `next`，实现循环扫描（Next-Fit）策略，显著减少搜索空闲位的开销。
- **安全机制**: 分配出的物理帧会自动进行内存清零（Zero-fill），防止前一个进程的数据残留导致信息泄漏。
- **接口定义**: 
  - `alloc()`: 返回 `Option<PhysPageNum>`。
  - `dealloc(ppn: PhysPageNum)`: 回收指定物理页号。

### 2.3 RAII 资源管理

通过 `FrameTracker` 结构体封装物理页帧的生命周期。`FrameTracker` 拥有一个物理页帧的所有权，当该实例被销毁（Drop）时，会自动调用分配器的回收接口释放资源。这种设计彻底避免了手动管理内存带来的泄漏风险。

## 3. 虚拟内存管理

虚拟内存管理基于 RISC-V SV39 分页模式，模块主要位于 `mm/page_table.rs` 和 `mm/memory_set.rs`。

### 3.1 SV39 分页机制

- **虚拟地址宽度**: 39 位
- **页表级数**: 3 级 (L2, L1, L0)
- **页表项 (PTE)**: 64 位，包含物理页号（PPN）和权限标志位。

### 3.2 权限控制 (PTE Flags)

页表项支持细粒度的硬件级权限控制：
- **V (Valid)**: 页表项是否有效。
- **R (Read)**: 是否可读。
- **W (Write)**: 是否可写。
- **X (Execute)**: 是否可执行。
- **U (User)**: 用户态是否可访问。如果未设置，则仅内核态可访问。
- **G (Global)**: 全局映射，TLB 刷新时不会被清除。
- **A (Accessed)**: 访问位，由硬件自动置位。
- **D (Dirty)**: 脏位，页面被写入时由硬件自动置位。

### 3.3 地址空间抽象 (MemorySet)

`MemorySet` 结构体是对一个完整的虚拟地址空间的抽象，它包含多级页表的根节点以及一系列逻辑段（`MapArea`）。

- **内核地址空间**: 
  - 采用**恒等映射 (Identity Mapping)**，即虚拟地址等于物理地址。
  - 这种设计简化了内核访问物理内存的操作，同时也便于访问内存映射I/O (MMIO) 区域。
  
- **用户地址空间**: 
  - 采用**按需映射 (Framed Mapping)**。
  - 包含用户程序的代码段、数据段、BSS段以及用户栈。
  - 用户栈大小默认为 8KB (`USER_STACK_SIZE`)。

- **跳板页 (Trampoline)**: 
  - 映射在虚拟地址空间的最高页 (`TRAMPOLINE`)。
  - 该页面在内核空间和所有用户空间中均可见，且映射到同一个物理页。
  - 用于处理用户态与内核态之间的上下文切换（Trap Entry/Exit）。

### 3.4 逻辑段管理 (MapArea)

`MapArea` 描述一段连续的虚拟地址区间，具有统一的映射属性和权限。

- **映射类型 (`MapType`)**:
    - `Identical`: 恒等映射，虚拟页号直接对应物理页号。
    - `Framed`: 帧映射，为每个虚拟页动态分配独立的物理帧。
- **映射权限**: 基于 `MapPermission` 位掩码，控制段的读写执行属性 (R/W/X/U)。

## 4. 动态内存分配 (Heap)

为了支持内核中使用动态数据结构（如 `Vec`, `BTreeMap`），系统实现了内核堆分配器。

- **分配器算法**: Buddy System Allocator (伙伴系统)。
- **实现库**: `buddy_system_allocator` crate。
- **堆配置**:
  - 大小: 8MB
  - 虚拟地址范围: `0x8042_0000` 至 `0x80C2_0000`
- **特性**: 支持高效的内存碎片合并，分配时间复杂度为 O(log n)。

## 5. 系统架构图

```text
┌───────────────────────────────────────────────┐
│              Memory Management Subsystem      │
├───────────────────────────────────────────────┤
│                                               │
│   ┌─────────────────┐    ┌────────────────┐   │
│   │ MemorySet       │    │ Heap Allocator │   │
│   │ (Address Space) │    │ (Global Alloc) │   │
│   └────────┬────────┘    └───────┬────────┘   │
│            │                     │            │
│            ▼                     │            │
│   ┌─────────────────┐            │            │
│   │ MapArea (Logi)  │            │            │
│   └────────┬────────┘            │            │
│            │                     │            │
│            ▼                     ▼            │
│   ┌─────────────────┐    ┌────────────────┐   │
│   │ PageTable (SV39)├───►│ FrameAllocator │   │
│   └─────────────────┘    │ (Phy Memory)   │   │
│                          └────────────────┘   │
└───────────────────────────────────────────────┘
```

## 参考资料

- [RISC-V Privileged Specification](https://riscv.org/technical/specifications/)
- [rCore Tutorial](https://rcore-os.github.io/rCore-Tutorial-Book-v3/)
- [OSDev Wiki](https://wiki.osdev.org/Memory_Management)

---

MIT License
